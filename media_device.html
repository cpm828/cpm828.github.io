<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>navigator.mediaDevices使用媒体输入</title>
  <style>
    video, img{
      width: 500px;
      height: 300px;
      border: 1px solid #000;
    }
    .grayscale {
      filter: grayscale(100%);
    }
    .sepia {
      filter: sepia(100%);
    }
    .blur {
      filter: blur(5px);
    }
  </style>
</head>
<body>
  <video autoplay></video>
  <br>
  <button id="share">屏幕分享</button>
  <button id="video">视频流</button>
  <button id="record">开始录制</button>
  <button id="stop">结束录制</button>
  <button id="capture">截屏</button>
  <button id="filter">css filter</button>
  <br><br><br>
  <img src=""/>

  <script>
    /**
     * MediaDevices: MediaDevices 接口提供访问连接媒体输入的设备，如照相机和麦克风，以及屏幕共享等。它可以使你取得任何硬件资源的媒体数据。
     *    事件：
     *        devicechange
     *    方法：
     *        getUserMedia: 会提示用户给予使用媒体输入的许可，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道。
     *        此流可以包含一个视频轨道、一个音频轨道，也可能是其他轨道类型
     *        getDisplayMedia: 提示用户去选择和授权捕获展示的内容或部分内容
     * 
     * MediaRecorder: 创建一个对指定的MediaStream进行录制的MediaRecorder对象
     *    事件：
     *        start
     *        pause
     *        stop
     * 
     *    方法：
     *        onstart:
     *        onpause:
     *        onstop:
     *        onerror:
     *        onwarning:
     *        ondataavailable: 响应运行代码 Blob 数据被提供使用
     *        
     * 
     * 流程：
     *  1. userMedia拉取本地视频流；getDisplayMedia选择和授权捕获展示的内容和窗口
     *  2. 用video标签实现播放：在video标签中使用autoplay属性或者在获取视频流数据后调用video.play()方法
     *  3. canvas实现视频截图保存
     *  4. 用mediaRecorder实现视频流的录制保存文件
     */

    // 获取元素
    const video = document.querySelector("video"),
        img = document.querySelector('img'),
        shareBtn = document.getElementById("share"),
        videoBtn = document.getElementById("video"),
        recordBtn = document.getElementById("record"),
        stopBtn = document.getElementById("stop"),
        captureBtn = document.getElementById('capture'),
        filterBtn = document.getElementById('filter');

    // 相关配置
    const constraints = {
      video: {
        width: 1280,
        heihgt: 720,
      },
      // video: true, // 摄像
      // video: { facingMode: "user" }, // 移动设备优先使用前置摄像头
      // video: { facingMode: "environment" }, // 使用后置摄像头
      // video: { facingMode: { exact: "environment" } }, // 强制使用后置摄像头

      audio: false, // 麦克风
    }

    let mediaRecorder = null, // 媒体记录对象
        mediaStream = null, // 媒体流
        buf = [];

    // 屏幕分享按钮：getDisplayMedia选择要录屏的内容/窗口（不需要权限）
    shareBtn.addEventListener("click", function () {
      navigator.mediaDevices
        .getDisplayMedia(constraints)
        .then((stream) => {
          video.srcObject = stream;
          mediaStream = stream;
        })
        .catch((err) => {
          console.log("Error:" + error);
        })
    }, false)

    // 视频流按钮：getUserMedia从摄像头获取视频流(需要摄像头权限)
    videoBtn.addEventListener("click", function () {
      navigator.mediaDevices
        .getUserMedia(constraints)
        .then((stream) => {
          video.srcObject = stream;
          mediaStream = stream;
        }).catch((err) => {
          console.log("Error:" + err);
          if (err.message.indexOf('Permission denied') > -1) console.log('请打开摄像头权限')
        })
    }, false)

    // 对视频流/捕获流进行录制
    recordBtn.addEventListener("click", function () {
      const options = {
        mimeType: "video/webm;codesc=vp8",
      }
      // if (!MediaRecorder.isTypeSupported(options.mimeType)) {
      //   console.log("不支持的视频格式");
      //   return;
      // }
      mediaRecorder = new MediaRecorder(mediaStream, options);
      mediaRecorder.addEventListener("dataavailable", function (e) {
        console.log(e)
        if (e && e.data && e.data.size > 0) {
          buf.push(e.data);
        }
      }, false)
      mediaRecorder.start(10)
    }, false)

    // 停止录屏，下载视频
    stopBtn.addEventListener("click", function () {
      if (mediaRecorder) {
        mediaRecorder.stop();
      }
      video.pause();
      const type = 'webm' || 'mp4';
      if (buf.length) {
        console.log('buf', buf)
        const blob = new Blob(buf, { type: "video/" + type }),
          url = window.URL.createObjectURL(blob),
          a = document.createElement("a");
        a.href = url;
        a.download = `mediarecorder${new Date().getTime()}.${type}`
        a.click();
      }
    }, false);

    // 截屏按钮点击事件
    captureBtn.addEventListener("click", function () {
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      img.src = canvas.toDataURL('image/webp');
      console.log('---img.src:', img.src)
    }, false)

    // 应用cssfilter效果
    filterBtn.addEventListener('click', () => {
      const filters = ["grayscale", "sepia", "blur", ""];
      const index = Math.floor(Math.random() * 4);
      video.className = filters[index];
    })
  </script>
</body>
</html>